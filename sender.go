package main

import (
	"net"
	"bufio"
	"os"
	"fmt"
	"strconv"
	"./message"
	"strings"
	"log"
)

// A "Sender" is capable of sending out messages that are generated by the user
type Sender struct {
	UserName string // The username of the sender
	IPAddress net.IP // The IP address of the sender
	Port int // The port being used by the sender
	StopChannel chan bool // Channel which will be used to indicate to the driver that the program can shut down
	Receiver *Receiver // The Receiver being used by the Sender
	Users map[string] *net.IP
}

const (
	COMMAND_HEAD = "/"
)

// Will cause the Sender to start and do its thing
func (s *Sender) Run(stopChannel chan bool) {
	s.StopChannel = stopChannel

	s.broadcastJoinMessage()
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		inputText := scanner.Text()

		if strings.HasPrefix(inputText, COMMAND_HEAD) {
			s.handleUserCommand(inputText, scanner)
		} else {
			message := s.buildMessage(inputText)
			s.sendMessage(message.String())
		}
	}
}

// This function will be used when the User requests a specific command, starting with '/' (ie /leave)
func (s *Sender) handleUserCommand(input string, scanner *bufio.Scanner) {
	commands := strings.Split(strings.TrimPrefix(input, COMMAND_HEAD), " ")

	switch commands[0] {
	case "leave":
		s.sendLeaveMessage()
		s.sendQuitMessage()
		break
	case "who":
		s.sendWhoMessage()
		break
	case "private":
		if(len(commands) < 2) {
			log.Print("You must provide the username of the person you want to send a private message to!")
		} else {
			s.sendPrivateMessage(commands[1], scanner) // Use the second index because it should have the
		}
	default:
		fmt.Println("Sorry, I didn't understand that command ... Try again ...")
	}
}

// Will broadcast a LEAVE message, and cause the user to leave the chat!
func (s *Sender) sendLeaveMessage() {
	m := s.constructEmptyMessageWithCommand(message.LEAVE)
	s.sendMessage(m.String())

	// Indicate through the StopChannel that we can exit now!
	s.StopChannel <- true
}

// Will send a QUIT message to the local receiver
func (s *Sender) sendQuitMessage() {
	m := s.constructEmptyMessageWithCommand(message.QUIT)
	s.sendLocalMessage(m.String())
}

// Will send a WHO message only to the local receiver
func (s *Sender) sendWhoMessage() {
	m := s.constructEmptyMessageWithCommand(message.WHO)
	s.sendLocalMessage(m.String())
}


// Broadcasts a PING message - not private so that the Receiver can call this!
func (s *Sender) SendPing() {
	m := s.constructEmptyMessageWithCommand(message.PING)
	s.sendMessage(m.String())
}


// Broadcasts to the network that the sender has joined
func (s Sender) broadcastJoinMessage() {
	m := s.constructEmptyMessageWithCommand(message.JOIN)
	s.sendMessage(m.String())
}

// Builds an empty Message with the requested command
func (s *Sender) constructEmptyMessageWithCommand(command message.MessageCommand) *message.Message{
	m := new(message.Message)
	m.Command = command
	m.Username = s.UserName
	m.Message = ""

	return m
}

// Constructs a message using the provided String as the contents of the message
func (s Sender) buildMessage(messageContents string) *message.Message {
	m := new(message.Message)
	m.Command = message.TALK
	m.Username = s.UserName
	m.Message = messageContents
	return m
}

// Sends the message out
func (s Sender) sendMessage(contents string) {
	// Send via UDP to the IP and Port
	broadcastAddr, err := net.ResolveUDPAddr("udp", s.IPAddress.String() + ":" + strconv.Itoa(s.Port))

	if err != nil {
		fmt.Errorf("Could not broadcast: %v", err)
	}
	SendMessageToAddress(broadcastAddr, contents)
}

func (s Sender) sendLocalMessage(contents string) {
	// Send via UDP to the IP and Port
	broadcastAddr, err := net.ResolveUDPAddr("udp", "0.0.0.0:" + strconv.Itoa(s.Port))

	if err != nil {
		fmt.Errorf("Could not broadcast: %v", err)
	}

	SendMessageToAddress(broadcastAddr, contents)
}

// Will be used to send a Private Message to the requested user!
func (s *Sender) sendPrivateMessage(username string, scanner *bufio.Scanner) {
	fmt.Print("Private message to " + username + ": ")
	scanner.Scan()
	messageContents := scanner.Text()

	// Build the message
	m := message.BuildMessage(message.PRIVATE_TALK, username, messageContents)
	s.sendLocalMessage(m.String())
}

func SendMessageToAddress(addr *net.UDPAddr, contents string) {

	udpSocket, err := net.Dial("udp", addr.String())
	if err != nil {
		fmt.Errorf("Could not use the UDP socket: %v", err)
	}
	udpSocket.Write([]byte(contents))
}



package main

import (
	"net"
	"bufio"
	"os"
	"fmt"
	"strconv"
	"./message"
	"strings"
)

// A "Sender" is capable of sending out messages that are generated by the user
type Sender struct {
	UserName string // The username of the sender
	IPAddress net.IP // The IP address of the sender
	Port int // The port being used by the sender
	StopChannel chan bool // Channel which will be used to indicate to the driver that the program can shut down
}

const (
	COMMAND_HEAD = "/"
)

// Will cause the Sender to start and do its thing
func (s Sender) Run(stopChannel chan bool) {
	s.StopChannel = stopChannel

	s.broadcastJoinMessage()
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		inputText := scanner.Text()

		if strings.HasPrefix(inputText, COMMAND_HEAD) {
			s.handleUserCommand(inputText)
		} else {
			message := s.buildMessage(inputText)
			s.sendMessage(message.String())
		}

	}
}

// This function will be used when the User requests a specific command, starting with '/' (ie /leave)
func (s Sender) handleUserCommand(input string) {
	switch strings.TrimPrefix(input, COMMAND_HEAD) {
	case "leave":
		s.sendLeaveMessage()
		s.sendQuitMessage()
		break
	case "who":
		s.sendWhoMessage()
		break
	}
}

// Will broadcast a LEAVE message, and cause the user to leave the chat!
func (s Sender) sendLeaveMessage() {
	m := s.constructEmptyMessageWithCommand(message.LEAVE)
	s.sendMessage(m.String())

	// Indicate through the StopChannel that we can exit now!
	s.StopChannel <- true
}

// Will send a QUIT message to the local receiver
func (s Sender) sendQuitMessage() {
	m := s.constructEmptyMessageWithCommand(message.QUIT)
	s.sendLocalMessage(m.String())
}

// Will send a WHO message only to the local receiver
func (s Sender) sendWhoMessage() {
	m := s.constructEmptyMessageWithCommand(message.WHO)
	s.sendLocalMessage(m.String())
}

// Broadcasts to the network that the sender has joined
func (s Sender) broadcastJoinMessage() {
	m := s.constructEmptyMessageWithCommand(message.JOIN)
	s.sendMessage(m.String())
}

// Builds an empty Message with the requested command
func (s Sender) constructEmptyMessageWithCommand(command message.MessageCommand) *message.Message{
	m := new(message.Message)
	m.Command = command
	m.Username = s.UserName
	m.Message = ""

	return m
}

// Constructs a message using the provided String as the contents of the message
func (s Sender) buildMessage(messageContents string) *message.Message {
	m := new(message.Message)
	m.Command = message.TALK
	m.Username = s.UserName
	m.Message = messageContents
	return m
}

// Sends the message out
func (s Sender) sendMessage(contents string) {
	// Send via UDP to the IP and Port
	broadcastAddr, err := net.ResolveUDPAddr("udp", s.IPAddress.String() + ":" + strconv.Itoa(s.Port))

	if err != nil {
		fmt.Errorf("Could not broadcast: %v", err)
	}
	sendMessageToAddress(broadcastAddr, contents)
}

func (s Sender) sendLocalMessage(contents string) {
	// Send via UDP to the IP and Port
	broadcastAddr, err := net.ResolveUDPAddr("udp", "0.0.0.0:" + strconv.Itoa(s.Port))

	if err != nil {
		fmt.Errorf("Could not broadcast: %v", err)
	}

	sendMessageToAddress(broadcastAddr, contents)
}

func sendMessageToAddress(addr *net.UDPAddr, contents string) {

	udpSocket, err := net.Dial("udp", addr.String())
	if err != nil {
		fmt.Errorf("Could not use the UDP socket: %v", err)
	}
	udpSocket.Write([]byte(contents))
}



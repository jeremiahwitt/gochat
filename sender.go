package main

import (
	"net"
	"bufio"
	"os"
	"fmt"
	"strconv"
	"./message"
)

// A "Sender" is capable of sending out messages that are generated by the user
type Sender struct {
	UserName string // The username of the sender
	IPAddress net.IP // The IP address of the sender
	Port int // The port being used by the sender
}

// Will cause the Sender to start and do its thing
func (s Sender) Run() {

	s.broadcastJoinMessage()
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		messageContents := scanner.Text()

		message := s.buildMessage(messageContents)
		s.sendMessage(message.String())
	}
}

// Broadcasts to the network that the sender has joined
func (sender Sender) broadcastJoinMessage() {
	m := new(message.Message)
	m.Command = message.JOIN
	m.Username = sender.UserName
	m.Message = ""
	sender.sendMessage(m.String())
}

// Constructs a message using the provided String as the contents of the message
func (s Sender) buildMessage(messageContents string) *message.Message {
	// TODO actually build the message
	m := new(message.Message)
	m.Command = message.TALK
	m.Username = s.UserName
	m.Message = messageContents
	return m
}

// Sends the message out
func (s Sender) sendMessage(contents string) {
	// TODO implement
	// Send via UDP to the IP and Port
	broadcastAddr, err := net.ResolveUDPAddr("udp", s.IPAddress.String() + ":" + strconv.Itoa(s.Port))

	if err != nil {
		fmt.Errorf("Could not broadcast: %v", err)
	}

	udpSocket, err := net.Dial("udp", broadcastAddr.String())

	if err != nil {
		fmt.Errorf("Could not use the UDP socket: %v", err)
	}

	udpSocket.Write([]byte(contents))
}
